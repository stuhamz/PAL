<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>PAL Evaluation Suite</title>
    <style>
        :root {
            --bg: #0f172a;
            --text: #f8fafc;
            --accent: #38bdf8;
            --pass: #4ade80;
            --fail: #f87171;
            --card: #1e293b;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', monospace;
            margin: 0;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: var(--accent);
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            width: 100%;
            max-width: 800px;
        }

        .card {
            background: var(--card);
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid var(--accent);
            position: relative;
        }

        .card h3 {
            margin-top: 0;
            color: #94a3b8;
            font-size: 0.9em;
        }

        .hash {
            font-family: monospace;
            font-size: 1.1em;
            word-break: break-all;
            margin: 10px 0;
        }

        .status {
            position: absolute;
            top: 20px;
            right: 20px;
            font-weight: bold;
        }

        .status.pending {
            color: #facc15;
        }

        .status.pass {
            color: var(--pass);
        }

        .status.fail {
            color: var(--fail);
        }

        button {
            background: var(--accent);
            color: #000;
            border: none;
            padding: 12px 30px;
            font-size: 1em;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 40px;
            transition: opacity 0.2s;
        }

        button:hover {
            opacity: 0.9;
        }

        #final-result {
            margin-top: 30px;
            font-size: 1.5em;
            font-weight: bold;
        }
    </style>
</head>

<body>

    <h1>PAL Identity Coherence Suite</h1>

    <div class="dashboard">
        <!-- Main World -->
        <div class="card" id="card-main">
            <h3>MAIN THREAD CONTEXT</h3>
            <div class="hash" id="hash-main">Running...</div>
            <div class="status pending" id="status-main">WAIT</div>
        </div>

        <!-- Web Worker -->
        <div class="card" id="card-worker">
            <h3>WORKER CONTEXT (Async Proxy)</h3>
            <div class="hash" id="hash-worker">Waiting...</div>
            <div class="status pending" id="status-worker">WAIT</div>
        </div>

        <!-- Iframe -->
        <div class="card" id="card-iframe">
            <h3>IFRAME CONTEXT (Propagator)</h3>
            <div class="hash" id="hash-iframe">Waiting...</div>
            <div class="status pending" id="status-iframe">WAIT</div>
        </div>

        <!-- Nested Iframe -->
        <div class="card" id="card-nested">
            <h3>NESTED IFRAME (Deep)</h3>
            <div class="hash" id="hash-nested">Waiting...</div>
            <div class="status pending" id="status-nested">WAIT</div>
        </div>
    </div>

    <div id="final-result"></div>
    <button onclick="runSuite()">RUN DIAGNOSTIC</button>

    <script>
        // --- SHARED FINGERPRINT FUNCTION ---
        // This simulates a standard canvas fingerprint.
        // We inject this source code into workers/iframes to ensure identical logic.
        const fingerprintSource = `
            function getFingerprint() {
                try {
                    // 1. Create Canvas
                    const isWorker = typeof importScripts === 'function';
                    let canvas;
                    if (typeof OffscreenCanvas !== 'undefined') {
                        canvas = new OffscreenCanvas(240, 60);
                    } else {
                        if (isWorker) throw new Error("OffscreenCanvas not supported in Worker");
                        canvas = document.createElement('canvas');
                        canvas.width = 240; canvas.height = 60;
                    }
                    
                    // 2. Draw Complex Scene
                    const ctx = canvas.getContext('2d');
                    ctx.textBaseline = "top";
                    ctx.font = "14px 'Arial'";
                    ctx.textBaseline = "alphabetic";
                    ctx.fillStyle = "#f60";
                    ctx.fillRect(125, 1, 62, 20);
                    ctx.fillStyle = "#069";
                    ctx.fillText("PAL_TEST_SIG", 2, 15);
                    ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
                    ctx.fillText("PAL_TEST_SIG", 4, 17);
                    
                    // 3. Extract PIXEL DATA (Robust comparison)
                    // We compare raw pixels to avoid PNG encoding differences between threads
                    const imageData = ctx.getImageData(0, 0, 240, 60);
                    const data = imageData.data;
                    
                    // Simple DJB2-like Hash of the pixel buffer
                    let hash = 5381;
                    for (let i = 0; i < data.length; i++) {
                        hash = ((hash << 5) + hash) + data[i];
                        hash = hash | 0; // Convert to 32bit integer
                    }
                    return Promise.resolve("PX:" + (hash >>> 0).toString(16)); // unsigned hex
                    
                } catch(e) { return Promise.resolve("ERROR: " + e.message); }
            }
        `;

        // Load Function into Main Scope
        eval(fingerprintSource);

        async function runSuite() {
            console.log("Starting Suite...");
            resetUI();

            // 1. MAIN THREAD
            const mainHash = await getFingerprint();
            updateCard('main', mainHash, 'PASS');

            // 2. WORKER (Async Proxy Test)
            try {
                const workerCode = `
                    ${fingerprintSource}
                    self.onmessage = async () => {
                        const sig = await getFingerprint();
                        self.postMessage(sig);
                    };
                `;
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const url = URL.createObjectURL(blob);
                const worker = new Worker(url);

                worker.onmessage = (e) => {
                    const workerHash = e.data;
                    const status = (workerHash === mainHash) ? 'PASS' : 'FAIL';
                    updateCard('worker', workerHash, status);
                    checkFinal(mainHash);
                };
                worker.postMessage('start');
            } catch (e) { updateCard('worker', e.message, 'FAIL'); }

            // 3. IFRAME (Propagator Test)
            try {
                const iframe = document.createElement('iframe');
                // Use absolute/hidden instead of display:none to ensure rendering engine (createImageBitmap) works
                iframe.style.position = 'absolute';
                iframe.style.left = '-10000px';
                iframe.style.visibility = 'hidden';
                document.body.appendChild(iframe);

                const win = iframe.contentWindow;
                // Inject function into iframe context
                const script = win.document.createElement('script');
                script.textContent = fingerprintSource + `
                    window.getFingerprint().then(h => window.parent.postMessage({type: 'iframe_result', hash: h}, '*'));
                `;
                win.document.body.appendChild(script);

                window.addEventListener('message', function h(e) {
                    if (e.data.type === 'iframe_result') {
                        const iframeHash = e.data.hash;
                        const status = (iframeHash === mainHash) ? 'PASS' : 'FAIL';
                        updateCard('iframe', iframeHash, status);
                        window.removeEventListener('message', h);
                        checkFinal(mainHash);

                        // 4. NESTED IFRAME (Deep Test)
                        runNestedTest(iframe, mainHash);
                    }
                });
            } catch (e) { updateCard('iframe', e.message, 'FAIL'); }
        }

        function runNestedTest(parentIframe, targetHash) {
            try {
                const win = parentIframe.contentWindow;
                const nested = win.document.createElement('iframe');
                win.document.body.appendChild(nested);

                const nestedWin = nested.contentWindow;
                const script = nestedWin.document.createElement('script');
                script.textContent = fingerprintSource + `
                    window.getFingerprint().then(h => window.parent.parent.postMessage({type: 'nested_result', hash: h}, '*'));
                `;
                nestedWin.document.body.appendChild(script);

                window.addEventListener('message', function h2(e) {
                    if (e.data.type === 'nested_result') {
                        const nestedHash = e.data.hash;
                        const status = (nestedHash === targetHash) ? 'PASS' : 'FAIL';
                        updateCard('nested', nestedHash, status);
                        window.removeEventListener('message', h2);
                        checkFinal(targetHash);
                    }
                });
            } catch (e) { updateCard('nested', e.message, 'FAIL'); }
        }

        function updateCard(id, hash, status) {
            const elHash = document.getElementById(`hash-${id}`);
            const elStatus = document.getElementById(`status-${id}`);
            elHash.innerText = hash.substring(0, 30) + "...";
            elStatus.innerText = status;
            elStatus.className = `status ${status.toLowerCase()}`;

            // Highlight diff
            if (status === 'FAIL') elHash.style.color = '#f87171';
        }

        function resetUI() {
            ['main', 'worker', 'iframe', 'nested'].forEach(id => {
                document.getElementById(`hash-${id}`).innerText = "Calculating...";
                document.getElementById(`status-${id}`).innerText = "PENDING";
                document.getElementById(`status-${id}`).className = "status pending";
            });
            document.getElementById('final-result').innerText = "";
        }

        function checkFinal(target) {
            const ids = ['worker', 'iframe', 'nested'];
            let allDone = true;
            let allPass = true;

            ids.forEach(id => {
                const s = document.getElementById(`status-${id}`).innerText;
                if (s !== 'PASS' && s !== 'FAIL') allDone = false;
                if (s === 'FAIL') allPass = false;
            });

            if (allDone) {
                const res = document.getElementById('final-result');
                if (allPass) {
                    res.innerHTML = "<span style='color: #4ade80'>✅ SYSTEM COHERENT: ALL CONTEXTS MATCH</span>";
                } else {
                    res.innerHTML = "<span style='color: #f87171'>❌ SYSTEM INCOHERENT: LEAKS DETECTED</span>";
                }
            }
        }
    </script>
</body>

</html>